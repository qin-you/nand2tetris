## Hints

A指令: 0vvvvvvvv...   只有@123 @R1 @LABEL 这三种类似形式，没有@D这种跟寄存器的形式，@后不跟寄存器。

C指令：111 comp dest jump， 汇编代码形式： dest = comp;jump  这是个通式，=和分号不能同时存在。 dest=comp只能使用寄存器，因为一条语句只能转成一条16位指令，有这个约束，一句话做的事情尽可能简单。

L命令类型： (LABEL) 只有这一种形式，不引起pc增加



变量存储从16开始，书上有规定，从1024开始也可以，但是对比输出结果会有区别。

第一遍只扫Label符号，第二遍扫变量符号和执行编译，变量必须先定义再使用，Label不一定。 第一遍不能同时扫Label和变量，此时@LABEL会被当作变量

使用提供编译器打开生成的二进制文件后，再跑一遍代码不能将修改同步到该二进制文件，但没有报错。估计写端被占据，debug时注意不要debug方法本身有bug。


编译器就是一个文本处理程序，把字符串从汇编语言格式转换/翻译到二进制字符串格式。


## 类说明
Assembler： 
流程控制，数据流由该类控制。 里面只有一个compile函数，用于调用其它类的方法，完成汇编语言的翻译。
- 第一遍扫描
  - 扫描标签符号并加入table
- 第二遍扫描
  - 扫描变量符号加入table
  - 解析当前行
  - 编码当前行
  - 保存当前行汇编语句对应的二进制
- 保存全部二进制结果


Parser： 
做两件事，且都在汇编语言空间，没有接触到二进制语言空间：
1. 处理原始汇编行，过滤注释行、空行，过滤行尾注释。 
2. 此外，根据汇编语句的type（C A L）把汇编语句的几个field分出来：
```c
        self.type = ''      # A C L instruction
        self.Avalue = ''    # A
        self.asmdest = ''   # C
        self.asmcomp = ''   # C
        self.asmjump = ''   # C
        self.asmlabel = ''  # L
```
记得每次解析新的汇编语句都要把上述变量初始化一下，防止交叉污染，会有问题。


Coder：
编码器，把汇编语句 编码成 二进制字符串

对于A指令：
如果是@123这种跟的立即数，把123换成二进制，按A指令格式与0拼接即可。
如果是@variable，跟的符号，从符号表获取对应地址，然后与0拼接即可。

对于C指令：
写comp  dest  jump  三个映射函数完成根据语法映射。 然后将parser中的当前语句的asmcomp asmdest asmjump 域拿到这三个映射函数中去得到相应二进制码。然后与111拼接。



SymboleTable：
两个作用：
1. 保存符号表   (key, value) 形式
2. 对外提供查询和增加符号的接口  contain  add




